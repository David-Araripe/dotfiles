export LS_OPTIONS="--color=auto"
alias q="squeue -u $(whoami)"
alias cancelalljobs="scancel -u $(whoami)"

function myjobs() {
        ps -fu "$(whoami)" | grep "$1"
}

function eyeball_q() {
        local refresh_rate=${1:-2}
        watch -n "$refresh_rate" "squeue -u \$(whoami)"
}

mobileq() {
    squeue -o "%.8i %.20j %.8P %.2t %.9M" "$@" -u "$(whoami)"
}

function backup_fep() {
    # Base command with guaranteed files
    local tar_cmd="tar -czf \"$(basename "$PWD")_backup.tar.gz\" --wildcards */*/FEP1/298/*/qfep.out */*/slurm*.out *.pdb *.json"

    # Check if any .sdf files exist
    if compgen -G "ligands.sdf" > /dev/null; then
        tar_cmd+=" ligands.sdf"
    fi

    if compgen -G "*/*/inputfiles/fep_config.json" > /dev/null; then
        tar_cmd+=" */*/inputfiles/fep_config.json"
    fi

    # Execute the command
    eval "$tar_cmd"
}

function fast_rmdir() {
    local dir_to_remove="$1"
    local tmp_dir="../.tmp_to_remove_$(date +%s%N)"  # Unique temp directory name

    if [ -z "$dir_to_remove" ]; then
        echo "Usage: fast_rmdir <directory>"
        return 1
    fi

    if [ ! -d "$dir_to_remove" ]; then
        echo "Error: '$dir_to_remove' is not a directory."
        return 1
    fi

    mkdir -p "$tmp_dir" && mv "$dir_to_remove"/* "$tmp_dir"
    rm -rf "$tmp_dir" &
    rm -r "$1"
}

gpu_queue_position() {
    local user="${1:-$USER}"

    echo "=== GPU Queue Priority for $user ==="
    echo ""

    # Get all pending jobs on GPU partitions
    local gpu_jobs=$(squeue -t PENDING -o "%i %u %P" --noheader | grep -i gpu)

    if [ -z "$gpu_jobs" ]; then
        echo "No pending GPU jobs in queue"
        return
    fi

    # Get all priorities (no -j filtering, it doesn't work with multiple jobs)
    local all_prios=$(sprio -o "%i %Y" --noheader)

    # Join and sort by priority (descending)
    local combined=$(join -1 1 -2 1 \
        <(echo "$gpu_jobs" | sort -k1,1) \
        <(echo "$all_prios" | sort -k1,1) \
        | awk '{print $4, $2, $1, $3}' \
        | sort -rn)

    if [ -z "$combined" ]; then
        echo "Could not get priority information"
        return
    fi

    # Show your jobs with their rank
    echo "Your jobs:"
    echo "$combined" | awk -v u="$user" '$2 == u {printf "  Priority: %10s (Rank: #%d/%d) - Partition: %s\n", $1, NR, NF, $4}' NF=$(echo "$combined" | wc -l)

    # Calculate stats
    local your_jobs=$(echo "$combined" | awk -v u="$user" '$2 == u {print $1}')
    local other_jobs=$(echo "$combined" | awk -v u="$user" '$2 != u {print $1}')

    echo ""
    echo "Queue stats:"
    printf "  Total pending GPU jobs: %d\n" $(echo "$combined" | wc -l)

    if [ -n "$your_jobs" ]; then
        local your_max=$(echo "$your_jobs" | sort -rn | head -1)
        local your_min=$(echo "$your_jobs" | sort -rn | tail -1)
        local your_avg=$(echo "$your_jobs" | awk '{sum+=$1; n++} END {printf "%.0f", sum/n}')
        printf "  Your priority range: %s - %s (avg: %s)\n" "$your_max" "$your_min" "$your_avg"
    fi

    if [ -n "$other_jobs" ]; then
        local other_max=$(echo "$other_jobs" | sort -rn | head -1)
        local other_min=$(echo "$other_jobs" | sort -rn | tail -1)
        local other_avg=$(echo "$other_jobs" | awk '{sum+=$1; n++} END {printf "%.0f", sum/n}')
        printf "  Others' priority range: %s - %s (avg: %s)\n" "$other_max" "$other_min" "$other_avg"
    fi
}

function allwaitingjobs {
    squeue | grep "PD       0:00" | wc -l
}

function allrunningjobs {
    squeue | awk '{print $5}' | grep -w "R" | wc -l
}

function waitingjobs() {
    q | grep "$(whoami) PD" | wc -l
}

function runningjobs() {
    q | grep "$(whoami)  R" | wc -l
}

function submitFEPjobs {
    # Path to the parent directory containing subdirectories
    PARENT_DIR=$(pwd)
    # Iterate over all subdirectories
    for dir in "$PARENT_DIR"/*; do
        if [ -d "$dir" ]; then  # Check if it is a directory
            echo "Entering $dir"
            cd "$dir"  # Enter the directory

            # Check if submitted.txt exists
            if [ -f "submitted.txt" ]; then
                echo "Directory $dir was already submitted on $(cat submitted.txt)"
            else
                # Check if exe_script.sh exists and is executable
                if [ -x "FEP_submit.sh" ]; then
                    sh FEP_submit.sh  # Execute the script
                    # Create timestamp file with human readable date
                    date "+%d/%m/%Y %H:%M:%S" > submitted.txt
                    echo "Job submitted and timestamp created"
                    sleep 2  # Wait for 2 seconds
                else
                    echo "FEP_submit.sh not found or not executable in $dir"
                fi
            fi
            cd ..  # Go back to the parent directory
        fi
    done
}

### Bash History Configuration ###
# Avoid duplicate and space-starting history entries.
HISTCONTROL=ignoreboth

# Commands to ignore in history.
HISTIGNORE='ls:ll:bg:fg:history:pwd:clear'

# Append to history, increasing file size instead of overwriting.
shopt -s histappend

# Set history length limits.
HISTSIZE=3000  # Max commands to remember.
HISTFILESIZE=5000  # Max lines in the history file.

# Automatically adjust window size.
shopt -s checkwinsize

# Synchronize command history across sessions.
export PROMPT_COMMAND="${PROMPT_COMMAND:+$PROMPT_COMMAND$'\n'}history -a; history -c; history -r"

# Adjust LINES and COLUMNS for the window size after each command.
shopt -s checkwinsize

# Source global definitions
if [ -f /etc/bashrc ]; then
        . /etc/bashrc
fi
